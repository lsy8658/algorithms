#include <stdio.h>
    /*
        dfs(0) 실행 후 visited가 전부 1이면 연결된 그래프입니다.

        if(adj[v][i] && !visited[i]) dfs(i);
        adj[v][i] → v와 i가 연결돼 있으면
        !visited[i] → i를 아직 안 갔으면
        그래서 갈 수 있고 안 가본 정점 i로 이동하라는 뜻입니다.
    */
    int n = 3; // 정점 개수
    int adj[3][3] =  { // 인접행렬
        {0,1,1},
        {1,0,0},
        {1,0,0},
    };
    int visited[3] = {0,0,0}; // 방문 여부 (0=미방문, 1=방문)

    void dfs(int v) {
        visited[v] = 1; // v 정점 방문 표시
        for (int i = 0; i < n; i++) {
            if (adj[v][i] && !visited[i]) dfs(i); // 이미 방문한적이 있으면 check 안함
        }
    }
int main () {
    dfs(0);  
    for(int i=0;i<n;i++)
        printf("정점 %d 방문 여부: %d\n", i, visited[i]);
    return 0;
}

/*
    DFS는 깊이 우선 탐색입니다.
    한 정점에서 시작해 갈 수 있는 곳을 끝까지 먼저 가보는 방식이에요.
    재귀나 스택으로 구현합니다.

    정점 0 방문 여부: 1
    정점 1 방문 여부: 1
    정점 2 방문 여부: 1
    여기선 모든 정점이 1 → 0번 정점에서 출발해서 모든 정점에 도달 가능

    즉, 그래프가 연결돼 있다는 의미입니다.
    이제 오일러 경로를 판단할 조건 중 연결성도 만족했다고 볼 수 있어요.


    adj[v][i] → v와 i가 연결돼 있는지 확인

    visited[i] → i를 이미 방문했는지 체크

    DFS 로직의 목적은 “모든 정점을 한 번씩 방문했는지” 확인하는 것

    간선 수가 아니라 정점 방문 여부가 관건이에요.

    간선 수는 상관이 없음 즉 간선이 있고 방문한 적이 없으면 순회하면서 표시해 주는거라 보면될듯
*/