#include <stdio.h>
// /*
//     차수는 정점에 연결된 간선의 개수야. 
//     (선 하나 연결되면 차수 1, 두 개면 차수 2. 
//     오일러 문제는 이 차수의 홀짝만 보면 됨.)

//     오일러 경로의 존재 여부를 확인하는 규칙은 다음과 같다.
//     1. 모든 간선을 한 번씩만 지나가는 경로 ( 한붓 그리기 같은 )
//     2. 홀수 차수 정점이 0개 또는 2개면 가능
//     3. 0개 -> 오일러 회로, 2개 -> 오일러 경로

//     정리하면 이렇게예요.
//     홀수 차수 정점이 0개면 시작=끝 → 오일러 회로.
//     2개면 서로 다른 시작·끝 → 오일러 경로.
//     1개나 3개 이상이면 간선을 한 번씩 못 지나서 불가능.

//     연결성이란 모든 정점이 간선으로 이어져 있는 상태예요.
//     어느 정점에서 시작해도 다른 정점으로 이동 가능해야 함.
//     끊어진 정점이 하나라도 있으면 오일러 경로 불가입니다.

//     오일러 경로 판단 순서: 차수 계산 → 홀수 개수 확인 →(나중에) 연결성.
// */
// int main () {
//     int n = 3;                 // 정점 개수
//     int adj[3][3] = {          // 인접행렬 (연결 여부)
//         {0,1,1},                 // 0번 정점
//         {1,0,0},                 // 1번 정점
//         {1,0,0}                  // 2번 정점
//     };
//     // 이제 차수 계산 코드:
//     for (int i = 0; i < n; i++) { // 현재 정점
//         int deg = 0; // i 정점의 차수
//         for (int j = 0; j < n; j++) {
//             if (adj[i][j]) {
//                 deg++;
//             }
//         }
//         printf("%d 정점 차수 => %d\n", i , deg);
//     }
// }

// /*
//     DFS/BFS = 그래프가 하나로 이어졌는지 확인하는 도구
//     DFS/BFS는 정점 하나에서 출발해서 갈 수 있는 곳을 전부 가보는 방법이에요.
//     그래서 한 번 시작했는데 모든 정점에 도착하면 → 연결된 그래프입니다.
//     모르면 시험·문제에선 보통 “그래프는 연결돼 있다”라고 가정해요.
// */

// // dfs까지 붙인다면
// int n = 3;                 // 정점 개수
// int adj[3][3] = {          // 인접행렬 (연결 여부)
//     {0,1,1},                 // 0번 정점
//     {1,0,0},                 // 1번 정점
//     {1,0,0}                  // 2번 정점
// };
// int visited[3] = {0,0,0};
// void dfs (int v) {
//     visited[v] = 1;
//     for (int i = 0; i < n; i++) {
//         if (adj[v][i] && !visited[i]) dfs(i); 
//     }
// }

// int main () {
//     // 이제 차수 계산 코드:
//     for (int i = 0; i < n; i++) { // 현재 정점
//         int deg = 0; // i 정점의 차수
//         for (int j = 0; j < n; j++) {
//             if (adj[i][j]) {
//                 deg++;
//             }
//         }
//         printf("%d 정점 차수 => %d\n", i , deg);
//     }
//     dfs(0);  
//     for(int i=0;i<n;i++)
//         printf("정점 %d 방문 여부: %d\n", i, visited[i]);
//     return 0;
// }


// 차수가 홀수인 정점 오일러 회로 0개, 오일러 경로 2개
int n = 3;
int adj[3][3] = {
  {0,1,0},  // 0 → 1
  {0,0,1},  // 1 → 2
  {1,0,0},  // 2 → 0
};

int eulerianPath (int count) {
    for (int i = 0; i < count; i++) {
        int check = 0;
        for (int j = 0; j < count; j++) {
            if (adj[i][j]) {
                check++;
            }
        }
        printf("%d의 간선의 수는 => %d\n", i, check);
    }
}
int visit[3] = {0,0,0};

int dfs (int idx) {
    visit[idx] = 1;
    for (int i = 0; i < n; i++) {
        if (adj[idx][i] && !visit[i]) dfs(i); 
    }
}

int main  () {
    eulerianPath(n);
}

/*
    한번도 안지나는 정점이 있다면요?

    그럼 오일러 경로가 아닙니다.
    간선이 있는 정점인데 한 번도 안 지났다면 모든 간선을 사용하지 못한 것이에요.
    단, 간선이 아예 없는 정점은 보통 판단에서 제외합니다.

    오일러 경로를 찾는 규칙
    - 각 정점의 차수가 홀수인 정점이 0개 혹은 2개이어야 한다.
    - 홀수점이 2개일 경우에는 홀수점에서 시작해야 한다.
*/