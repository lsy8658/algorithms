알고리즘은 주어진 문제를 해결하기 위한 일련의 단계적인 처리 과정으로

레시피와 같다.

알고리즘은 다음과 같은 조건을 모두 만족해야한다. 
1.입출력: 외부에서 0개 이상의 입력을 받아서 하나 이상의 출력을 생성해야 한다.
2.명확성: 각 단계(명령)는 모호하지 않고 단순하고 명확해야 한다.
3.유한성: 한정된 수의 단계를 거친 후에는 반드시 끝나야 한다.
4.유효성: 모든 명령은 컴퓨터에서 수행할 수 있어야 한다.




- 최솟값 알고리즘
- 탐색 알고리즘
(뒤섞인 카드에서 10을 찾는 경우)

순차탐색 : 앞에서부터 하나씩 찾는 것
이진탐색 : 순서대로! 나열된 카드 중에 10을 찾는다면? ( 중간, 크면 오른쪽 중간, 작으면 왼쪽 중간)
이런식으로 찾아나감 순서대로 나열되었다는 전제하에

대표적인 알고리즘 설계 기법
- 욕심쟁이 greedy 방법
- 분할정복 divide-and-conquer 방법
- 동적 프로그래밍 dynamic programming 방법 

"1 ) 그리디 greedy 알고리즘 : 탐욕적 방법, 탐욕 알고리즘"
해를 구하는 일련의 선택 과정에서 전후 단계의 선택과는 상관없이
[ 각 단계마다 가장~~최선 이라고 여겨지는 국부적인 최적해를 선택해
나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 ] 
희망적인 전략을 취하는 방법 -> 항상 전체적인 최적해를 만들지 못할 수도 있음
간단하면서 효율적인 알고리즘을 만들 수 있는 강력한 기법

최솟값/ 최댓값을 구하는 최적화 문제에 주로 사용

1] 거스름돈 문제
고객에게 돌려줄 거스름돈이 T만큼 있을 때 고객이
받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는
방법을 찾는 문제

기본 해결 방법 => 거스름돈의 액수를 초과하지 않으면서
동전의 액면가가 단순히 큰 것부터 '욕심을 부려서'최대한 뽑아서 거스름돈을 만듦
가정 -> 500원 100원 50원 10원

각 단계에서 가장 최선이란걸 선택하면 
전체적으로 가장 최적해를 구할 수 있다.

가정 -> 500원 120원 100원 50원 10원 (120원이 추가됨)

500원 1개 100원 1개 50원 1개

동전의 액면가가 일반적인 경우에는 욕심쟁이 방법으로 해결 불가

2] 배낭문제
최대 용량 M인 하나의 배낭, n개의 물체가 있다고 가정
각 물체 i에는 물체의 무게 W(i)와 해당 물체를 배낭에
넣었을 때 얻을 수 있는 이익 P(i) 가 부여됨

배낭의 용량을 초과하지 않는 범위 내에서
배낭에 들어 있는 물체들의 이익의 합이 최대가 되도록
물첵를 넣는 방법( 또는 최대 이익 )을 찾는 문제

가정 -> 물체를 쪼개서 넣을 수 있음
각물체마다 무게와 이익이 같이 부여가 되어있음

기본 해결 방안으로는
물체의 무게는 적으면서도 이익이 가장 큰 물체부터 골라서
'욕심을 내어' 최대한 넣는 과정을 반복
단위 무게당 이익이 가장 큰 물체부터 최대한 넣는 과정을 반복
- 물체를 통째로 넣을 수 없으면 배낭의 남은 용량에 맞게 물체를
쪼개서 넣음